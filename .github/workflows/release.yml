name: Release

on:
  push:
    tags:
      - 'v*'

env:
  CARGO_TERM_COLOR: always
  SQLX_OFFLINE: true

jobs:
  build-windows:
    name: Build Windows Installer
    runs-on: windows-latest
    permissions:
      id-token: write
      contents: write
    steps:
      - uses: actions/checkout@v4

      - name: Extract version from tag
        id: version
        shell: bash
        run: echo "VERSION=${GITHUB_REF_NAME}" >> "$GITHUB_OUTPUT"

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Rust cache
        uses: Swatinem/rust-cache@v2
        with:
          cache-on-failure: true

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: npm
          cache-dependency-path: red_coral/package-lock.json

      - name: Install frontend dependencies
        run: npm ci --legacy-peer-deps
        working-directory: red_coral

      - name: Install NASM (for aws-lc-rs)
        uses: ilammy/setup-nasm@v1

      - name: Build Tauri app (signed for updater)
        working-directory: red_coral
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        run: npx tauri build

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: eu-south-2

      - name: Upload to S3 and generate manifest
        id: upload
        shell: bash
        env:
          S3_BUCKET: ${{ secrets.UPDATE_S3_BUCKET }}
          DOWNLOAD_BASE: ${{ secrets.UPDATE_DOWNLOAD_BASE_URL }}
          VERSION: ${{ steps.version.outputs.VERSION }}
        run: |
          set -euo pipefail

          # Tauri workspace member outputs to workspace root target/
          NSIS_DIR="target/release/bundle/nsis"
          if [ ! -d "$NSIS_DIR" ]; then
            # Fallback: check under red_coral/ in case of non-workspace build
            NSIS_DIR="red_coral/target/release/bundle/nsis"
          fi

          echo "==> NSIS directory contents:"
          ls -la "${NSIS_DIR}/" || { echo "ERROR: NSIS dir not found"; exit 1; }

          # Upload .exe installer (for fresh installs + Tauri v2 updater)
          INSTALLER=$(find "${NSIS_DIR}" -maxdepth 1 -name "*.exe" ! -name "*.sig" | head -1)
          if [ -z "$INSTALLER" ]; then
            echo "ERROR: No .exe installer found in ${NSIS_DIR}"
            exit 1
          fi
          INSTALLER_NAME="redcoral-pos_${VERSION}_x64-setup.exe"
          aws s3 cp "$INSTALLER" \
            "s3://${S3_BUCKET}/releases/${VERSION}/${INSTALLER_NAME}"
          # Also upload to updates/ for Tauri updater
          aws s3 cp "$INSTALLER" \
            "s3://${S3_BUCKET}/updates/${INSTALLER_NAME}"
          echo "Uploaded installer: $INSTALLER"

          # Read updater signature (.exe.sig — Tauri v2 signs the .exe directly)
          EXE_SIG=$(find "${NSIS_DIR}" -maxdepth 1 -name "*.exe.sig" | head -1)
          if [ -z "$EXE_SIG" ]; then
            echo "ERROR: No .exe.sig found — TAURI_SIGNING_PRIVATE_KEY may not be set"
            exit 1
          fi
          SIGNATURE=$(cat "$EXE_SIG")
          echo "Signature loaded from: $EXE_SIG"

          # Generate update manifest (Tauri v2 updater format)
          # MANDATORY_MIN_VERSION: clients below this version are forced to update.
          # Set via GitHub Actions variable for critical releases, e.g. "1.1.0"
          # Persists across subsequent non-critical releases — only bump forward.
          if [ -n "${MANDATORY_MIN_VERSION:-}" ]; then
            MANDATORY_FIELD="\"mandatory_min_version\": \"${MANDATORY_MIN_VERSION}\","
          else
            MANDATORY_FIELD=""
          fi
          cat > latest.json <<MANIFEST
{
  "version": "${VERSION#v}",
  "notes": "Release ${VERSION}",
  "pub_date": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  ${MANDATORY_FIELD}
  "platforms": {
    "windows-x86_64": {
      "signature": "${SIGNATURE}",
      "url": "${DOWNLOAD_BASE}/updates/${INSTALLER_NAME}"
    }
  }
}
MANIFEST

          aws s3 cp latest.json "s3://${S3_BUCKET}/updates/latest.json" \
            --content-type "application/json"

          echo ""
          echo "==> Release ${VERSION} uploaded successfully"
          echo "    Installer: s3://${S3_BUCKET}/releases/${VERSION}/"
          echo "    Updater:   s3://${S3_BUCKET}/updates/latest.json"

          # Save paths for GitHub Release step
          echo "INSTALLER_PATH=${INSTALLER}" >> "$GITHUB_OUTPUT"
          echo "INSTALLER_NAME=${INSTALLER_NAME}" >> "$GITHUB_OUTPUT"

      - name: Create GitHub Release
        env:
          GH_TOKEN: ${{ github.token }}
          VERSION: ${{ steps.version.outputs.VERSION }}
        run: |
          gh release create "$VERSION" \
            --title "RedCoral POS $VERSION" \
            --generate-notes \
            --draft \
            "${{ steps.upload.outputs.INSTALLER_PATH }}#${{ steps.upload.outputs.INSTALLER_NAME }}"
