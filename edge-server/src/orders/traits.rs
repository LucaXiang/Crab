//! Core traits for the CommandHandler architecture
//!
//! This module defines the traits that enable the Strategy Pattern for order command processing:
//! - `CommandHandler`: Executes commands and generates events
//! - `EventApplier`: Applies events to snapshots (pure function, no side effects)

use crate::orders::storage::OrderStorage;
use async_trait::async_trait;
use redb::WriteTransaction;
use shared::order::{OrderEvent, OrderSnapshot};
use std::collections::HashMap;
use thiserror::Error;

/// Errors that can occur during order operations
#[derive(Debug, Error)]
pub enum OrderError {
    #[error("Order not found: {0}")]
    OrderNotFound(String),

    #[error("Order already completed: {0}")]
    OrderAlreadyCompleted(String),

    #[error("Order already voided: {0}")]
    OrderAlreadyVoided(String),

    #[error("Item not found: {0}")]
    ItemNotFound(String),

    #[error("Payment not found: {0}")]
    PaymentNotFound(String),

    #[error("Insufficient quantity")]
    InsufficientQuantity,

    #[error("Invalid amount")]
    InvalidAmount,

    #[error("Invalid operation: {0}")]
    InvalidOperation(String),

    #[error("Table is already occupied: {0}")]
    TableOccupied(String),

    #[error("Storage error: {0}")]
    Storage(String),
}

/// Command metadata extracted from OrderCommand
#[derive(Debug, Clone)]
pub struct CommandMetadata {
    pub command_id: String,
    pub operator_id: String,
    pub operator_name: String,
    pub timestamp: i64,
}

/// Command execution context
///
/// Provides:
/// - Access to the write transaction
/// - Snapshot cache to avoid redundant reads
/// - Order creation utilities
pub struct CommandContext<'a> {
    txn: &'a WriteTransaction,
    storage: &'a OrderStorage,
    snapshot_cache: HashMap<String, OrderSnapshot>,
    next_sequence: u64,
}

impl<'a> CommandContext<'a> {
    pub fn new(
        txn: &'a WriteTransaction,
        storage: &'a OrderStorage,
        current_sequence: u64,
    ) -> Self {
        Self {
            txn,
            storage,
            snapshot_cache: HashMap::new(),
            next_sequence: current_sequence + 1,
        }
    }

    /// Load a snapshot, using cache if available
    pub fn load_snapshot(&mut self, order_id: &str) -> Result<OrderSnapshot, OrderError> {
        if let Some(snapshot) = self.snapshot_cache.get(order_id) {
            return Ok(snapshot.clone());
        }

        let snapshot = self
            .storage
            .get_snapshot_txn(self.txn, order_id)
            .map_err(|e| OrderError::Storage(e.to_string()))?
            .ok_or_else(|| OrderError::OrderNotFound(order_id.to_string()))?;

        self.snapshot_cache
            .insert(order_id.to_string(), snapshot.clone());
        Ok(snapshot)
    }

    /// Create a new snapshot and add to cache
    pub fn create_snapshot(&mut self, order_id: String) -> OrderSnapshot {
        let snapshot = OrderSnapshot::new(order_id.clone());
        self.snapshot_cache.insert(order_id, snapshot.clone());
        snapshot
    }

    /// Save a snapshot to the cache (actual persistence happens in manager)
    pub fn save_snapshot(&mut self, snapshot: OrderSnapshot) {
        self.snapshot_cache
            .insert(snapshot.order_id.clone(), snapshot);
    }

    /// Get all modified snapshots for persistence
    pub fn modified_snapshots(&self) -> impl Iterator<Item = &OrderSnapshot> {
        self.snapshot_cache.values()
    }

    /// Get the write transaction
    pub fn txn(&self) -> &WriteTransaction {
        self.txn
    }

    /// Get the storage
    pub fn storage(&self) -> &OrderStorage {
        self.storage
    }

    /// Check if a table is occupied by an active order
    ///
    /// Returns the order_id if the table is occupied.
    pub fn find_active_order_for_table(&self, table_id: &str) -> Result<Option<String>, OrderError> {
        self.storage
            .find_active_order_for_table_txn(self.txn, table_id)
            .map_err(|e| OrderError::Storage(e.to_string()))
    }

    /// Allocate a new sequence number
    pub fn next_sequence(&mut self) -> u64 {
        let seq = self.next_sequence;
        self.next_sequence += 1;
        seq
    }
}

/// Command handler trait
///
/// Implementations execute business logic and generate events.
/// This trait is called when processing NEW commands, not when replaying events.
#[async_trait]
pub trait CommandHandler: Send + Sync {
    /// Execute the command and return generated events
    ///
    /// # Arguments
    /// - `ctx`: Execution context with transaction and snapshot cache
    /// - `metadata`: Command metadata (operator, timestamp, etc.)
    ///
    /// # Returns
    /// - `Ok(Vec<OrderEvent>)`: Events generated by this command
    /// - `Err(OrderError)`: If the command cannot be executed
    async fn execute(
        &self,
        ctx: &mut CommandContext<'_>,
        metadata: &CommandMetadata,
    ) -> Result<Vec<OrderEvent>, OrderError>;
}

/// Event applier trait
///
/// Implementations apply event data to snapshots.
/// This is a PURE function - no business logic, no side effects, no I/O.
/// Used for both command execution and event replay.
pub trait EventApplier: Send + Sync {
    /// Apply the event to the snapshot
    ///
    /// # Guarantees
    /// - Pure function: same input always produces same output
    /// - No I/O operations
    /// - No ID generation (IDs come from the event)
    /// - No business logic validation
    fn apply(&self, snapshot: &mut OrderSnapshot, event: &OrderEvent);
}
